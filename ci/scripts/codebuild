#!/usr/bin/env planck

(require '[planck.shell :refer [sh]])
(require '[clojure.string :as str])
(require '[planck.core :as core])

(defn json-out [shell-result]
  (-> shell-result
      :out js/JSON.parse (js->clj :keywordize-keys true)))

(defn start-build [project version]
  (println "Starting CodeBuild for" project "with source version" version)
  (-> (sh "aws" "codebuild" "start-build"
          "--project-name" project
          "--source-version" version)
      json-out
      (get-in [:build :id])))

(defn get-log-info
  "Returns cloudwatch group and stream name for build logs"
  [build-id]
  (-> (sh "aws" "codebuild" "batch-get-builds"
          "--ids" build-id)
      json-out
      (get-in [:builds 0 :logs])
      ((juxt :groupName :streamName))))

(defn get-build-info [build-id]
  (-> (sh "aws" "codebuild" "batch-get-builds" "--ids" build-id)
      json-out
      (get-in [:builds 0])))

(defn sleep [seconds]
  (sh "sleep" (str seconds)))

(defn tail-build-logs
  ([log-info]
   (tail-build-logs log-info nil))
  ([[group stream] since-timestamp]
   (let [logs
         (->> (sh "aws" "logs" "get-log-events"
                  "--log-group-name" group
                  "--log-stream-name" stream
                  "--start-time" (str (inc (or since-timestamp 0))))
              json-out
              :events
              (mapv (juxt :timestamp :message)))]
     (with-meta (mapv second logs)
       {:last-timestamp (reduce max (map first logs))}))))

(defn print-logs [lines]
  (doseq [line lines]
    ;; Move to beginning of line and clear the line... then print the message
    (print "\u001b[1000D\u001b[2K" line)))

(defn wait-for-completion [project-name version build-id]
  (let [start-time (.getTime (js/Date.))
        elapsed #(.toFixed (/ (- (.getTime (js/Date.)) start-time) 1000) 0)
        log-info (get-log-info build-id)
        poll (fn [last-timestamp]
               (sleep 2)
               (let [logs (tail-build-logs log-info last-timestamp)
                     info (get-build-info build-id)]
                 (when (seq logs)
                   (print-logs logs))
                 (assoc info :last-log-timestamp (or (-> logs meta :last-timestamp)
                                                     last-timestamp))))]
    (loop [{:keys [buildComplete currentPhase last-log-timestamp] :as build-info}
           (poll nil)
           [s & spinner] (cycle ["|" "/" "-" "\\"])]
      (if buildComplete
        build-info
        (do
          (print "\u001b[1000D\u001b[2K\u001b[7m"
                 (str "[" project-name "@" version "] (" (elapsed) "s) ")
                 s " " currentPhase "\u001b[0m")
          (recur (poll last-log-timestamp) spinner))))))

(defn notify [project status]
  (sh "osascript" "-e" (str "display notification \"" status "\" with title \"" project "\"")))

(let [[project version & _] *command-line-args*
      version (or version "master")
      build-id (start-build project version)]
  (println "Build ID: " build-id)
  (let [{status :buildStatus} (wait-for-completion project version build-id)]
    (println "Finished build: " build-id " => " status)
    (notify project status)
    (core/exit (if (= "SUCCEEDED" status) 0 1))))
